
## 指令系统

#### 基础知识
###### 格式
![[Pasted image 20251224102516.png]]
指令中一般会包含：
	1. 操作码（Operation Code）
	2. 目标操作数 （Destination operand）
	3. 源操作数 （Source operand）

#### 常用指令

##### 1. 数据传送类 (Data Transfer) —— “搬运工”

这类指令的作用是将数据从一个地方“复制”到另一个地方，**源操作数的内容不会改变**。

- **MOV (Move):** 最基础的传送。
    
    - **怎么用：** `MOV 目的, 源`。例如 `MOV AX, BX` 是把 BX 的内容复制给 AX。
        
- **PUSH / POP:** 堆栈操作。
    
    - **怎么用：** `PUSH AX` 把数据存入堆栈“压入”；`POP AX` 把数据从堆栈“弹出”。
        
- **LEA / LDS / LES (地址传送):** * **是什么：** 它们不传数据本身，而是传送数据的**地址**（指针）。
	-  **LEA 与 LDS 以及LES之间的区别**: LEA只将源操作数的偏移地址（EA）传输给目标寄存器， LDS是将首先从内存读取32的远指针，然后将前两个字节传递给目标寄存器，后两个字节传递给段寄存器DS。 LES也是类似只不过是将后两个字节传递给了ES而不是DS，这个操作常用再串操作（如MOVS）之前进行使用，用来快速指向目标缓冲器（ES:DI）。
    - **怎么用：** `LEA BX, [SI+6]` 是把计算出来的地址值给 BX，而不是地址里的内容。
        
- **IN / OUT:** I/O 端口操作。
    
    - **怎么用：** 用于 CPU 与外部接口（如硬盘、键盘）交换数据。
    - 例子： IN（input）:数据必须经过 **AL 或 AX** 寄存器。
		- `IN AL, 60H`：从 60H 号端口（通常是键盘）读一个字节到 AL。
		- `IN AX, DX`：如果端口号大于 255，必须先存入 DX，再通过 DX 读取一个字。
	- 例子：OUT（output）同样必须通过 **AL 或 AX**。
		- `OUT 61H, AL`：把 AL 里的数据发给 61H 号端口（通常控制蜂鸣器）

---

##### 2. 算术运算类 (Arithmetic Calculation) —— “计算器”

这类指令执行数学运算，并会改变 **FLAGS** 寄存器里的状态位。

- **ADD / ADC:** 加法。
    
    - **怎么用：** `ADD AX, [SI+6]`。`ADC` 则是“带进位加法”，会将之前运算产生的 **CF** 位一起加进来。
        
- **SUB / SBB:** 减法。
    
    - **怎么用：** `SUB AX, BX`。`SBB` 是“带借位减法”，会减去之前的借位 **CF**。
        
- **INC / DEC:** 加1 / 减1。
    
    - **怎么用：** `INC [BX]` 将内存里的内容直接加 1。这比 `ADD Op, 1` 占用的指令空间更小。
        
- **CMP (Compare):** 比较操作。
	- **原理：** 执行 `目的操作数 - 源操作数`，丢弃结果，只更新 **ZF、CF、SF、OF** 等状态位
    - **是什么：** 它的本质是**做减法**，但不保存计算结果，只为了通过结果改变标志位（如 ZF, CF）。
        
    - **怎么用：** `CMP AX, BX`。之后通常紧跟一个跳转指令（如 `JZ`）来判断两者是否相等。
        

---

##### 3. 逻辑运算类 (Logical) —— “位操作器”

这类指令按二进制位进行逻辑判断。

- **AND / OR / XOR:** 与、或、异或。
    
    - **怎么用：** 常用于“屏蔽”或“提取”某些特定位。例如 `AND AL, 0FH` 可以只保留 AL 的低 4 位，将高 4 位清零。
        
- **TEST:** 逻辑测试。
	- **原理：** 执行 `目的操作数 AND 源操作数`（逻辑与），丢弃结果，更新标志位。    
    - **是什么：** 类似于 `CMP` 之于 `SUB`。`TEST` 实际上做的是 **AND** 运算但不存结果，只影响标志位。


---

##### 4. 移位类 (Bit Shift) —— “位移机”

将二进制位向左或向右移动。

- **SHL / SHR:** 逻辑左移/右移。空出的位补 **0**。
    
- **SAR:** 算术右移。用于有符号数，空出的位补**符号位**。
	- **是什么：** 将二进制位向右移，但**保持最高位（符号位）不变**。
	- **怎么用：** `SAR AL, 1`（将 AL 里的数右移一位）。
		- 如果 AL 原本是 `-4` (`1111 1100`)。
	    - 右移后变为 `1111 1110` (`-2`)。
	- **场景：** 专门用于有符号整数的“快速除以 2”。
	
- **ROL / ROR:** 循环移位。移出去的一位会绕回到另一头补上。
    

---

##### 5. 串操作类 (String Operation) —— “批量处理器”

专门用于处理内存中连续的多个字节（字符串）。

- **MOVS / CMPS:** 串传送 / 串比较。
    
- **特点：** 它们会自动递增或递减指针（SI 和 DI），通常配合 `REP` 前缀使用，实现“一条指令处理一整块内存”。
    

---

##### 6. 控制转移类 (Control Shift) —— “导航员”

改变程序的执行路线（修改 **CS** 和 **IP** 寄存器）。

- **JMP:** 无条件跳转。直接跳到指定行。
    
- **Jcc (如 JZ, JC):** 条件跳转。**只有当满足特定条件（看标志位）时才跳**。
    
    - _例：_ `JZ` 表示“如果结果为零（ZF=1），就跳转”。
        
- **CALL / RET:** 调用和返回子程序（函数）。
    
- **LOOP:** 循环指令。
    
    - **怎么用：** 它会自动检查 **CX** 寄存器的值，如果 `CX != 0` 就自动减 1 并跳回循环开始处。

#### 操作数
##### 操作数的分类
1. 立即数（Immdiate Operands）(constant)
2. 寄存器操作数（register Operands）
3. 存储器操作数 (memory Operands)

###### 立即数
   数据本身直接参与运算（8bit 或者是 16bit），**立即数不能作为目标操作数** ，立即数可以是正数也可以是负数，但是它的值需要在leagl的范围中

```
  MOV AX,1234H %%在这个代码中1234H就作为我们的立即数 注意到1234H是一个16bit的，所以我们要给到AX
  MOV BL, 22H %% 在这个代码中22H就是我们的立即数，也同时注意到22H是一个8bit的，所以我们不能给BX，而是要给BL，因为这个是低八位作为标准
```
###### 寄存器操作数
   存储在8个通用寄存器（数据寄存器（AX,BX,CX,DX），地址指针寄存器(SP, BP)，变址寄存器(SI,DI) ）以及4的段寄存器(CS:代码段，DS: 数据段，ES:附加段，SS：堆栈段) 里面的操作数，如下图所示
   ![[Pasted image 20251224113016.png]]![[Pasted image 20251224113413.png]]
```
   MOV AX,BX
   %% 这里其实BX就是我们的寄存器操作数。 注意到BX是一个16bit的操作数，所以我们也要用AX来进行接受
   MOV DL,CH
    %% 这里其实CH就是我们的寄存器操作数。 注意到CH是一个8bit的操作数，所以我们要用DL来进行接收。
```

###### 存储器操作数
表示用于计算的数据已被存入一个或两个寄存器单元
下面是存储器操作数的执行的过程：
```
MOV AX, [1200H]
%%[1200H]就是代表的是找到1200H的这个偏移地址，然后将这个里面的数据取出来，给到AX，因为这里面是16bit的数据，所以其要把高8位数据传递给AH，低八位数据传递给AL
```
![[Pasted image 20251224114522.png]]
- 如果指令中没有明确指明使用哪个段寄存器，CPU 会根据操作数的类型，自动指定一个**默认的段寄存器**。
- 8088 有 4 个段寄存器，它们在程序运行中各司其职：
	- **CS (Code Segment)：** 存放**代码段**的基地址。CPU 从这里提取要执行的指令。
	- **DS (Data Segment)：** 存放程序主要的**数据段**基地址。大部分变量和常数都在这里。
	- **SS (Stack Segment)：** 存放**堆栈段**基地址。用于函数调用、局部变量和临时保护数据。
	- **ES (Extra Segment)：** **附加段**基地址。常用于串操作（如大块内存复制）时的目标区域。
- 内存操作数的**偏移地址**（也叫有效地址 EA）可以通过多种**寻址方式**计算出来。这就是你之前看到的那些复杂的公式
	- **直接确定：** 指令里直接写死地址，如 `[1234H]`。
	- **寄存器确定：** 偏移地址就在寄存器里，如 `[BX]`。
	- **计算确定：** 偏移地址由几个部分相加得到，如 `[BX + SI + 6]`。
	    - 在这里，`BX` 是基址，`SI` 是变址，`6` 是位移量。CPU 会把它们加在一起，算出最终的**偏移地址**。
	    ![[Pasted image 20251224115642.png]]
	    上面的操作都是相同的
	![[Pasted image 20251224120205.png]]
	8086的寻址方式：
	1. 立即寻址（immediate addressing）==指令执行速度快，不需要访问寄存器或者内存==
		`MOV AX, 1234H`
		`MOV BYTE PTR[2A00H], 8FH`
		
	2. 直接寻址（Direct Addressing）**指令中直接给出操作数在内存中16位偏移地址**
		`MOV AL, [2A00H]`
		`MOV DX, ES:[2A00H]`
		`MOV SI, TABLE_PTR`
		
	3. 寄存器寻址（Register Addressing） **操作数存放在 CPU 内部的寄存器中。**
		`MOV AX, BX`
		`MOV [3F00H], AX`
		`MOV CL,AL`
		

	4. 寄存器间接寻址（Register Indirect Addressing）操作数的**偏移地址**存放在某个**寄存器**中==（只有是 BX, BP, SI 或 DI）==。
		**记住BX, SI, DI 这些是关系在DS中**
		**BP是关系在SS中**
		`MOV AL, [DI]`
		`MOV CL, CS:[DI]`
		
	5. 寄存器相对寻址 (Register Relative Addressing)偏移地址等于**一个寄存器**的内容加上一个**常数（位移量）**
		`MOV AL, [BX+0A00H]`
		`MOV AX [BX+8]`
		`MOV CX, TABLE[SI]`
		`MOV AX, [BP+1000H]`
		
	6. 基址变址寻址(Based Indexed Addressing)偏移地址等于一个**基址寄存器**（BX 或 BP）的内容加上一个**变址寄存器**（SI 或 DI）的内容。
		`MOV AL, [BX][SI]`
		`MOV AX, [BX+SI]`
		`MOV AX, DS:[BP][DI]`
		
	7. 相对基址变址寻址(Indexed plus Displacement Addressing)这是最复杂的内存寻址方式。==**偏移地址 = 基址寄存器 + 变址寄存器 + 位移量**。==
		`MOV AX, [BX+SI+6]`
		`MOV AX, DATA [SI][BX]`
		`MOV AX, [BX+DATA][SI]`
		`MOV AX, [BX]DATA[SI]`
		`MOV AX, [BX+SI] DATA`
		
	8. 隐含寻址(Implied Addressing) 指令中没有明确给出操作数，但操作数已隐含在操作码中。
		`HLT or MUL BL`
![[Pasted image 20251224161338.png]]
(a) 寄存器寻址
(b) 立即寻址
(c) 寄存器间接寻址
(d) 寄存器间接寻址
(e) 寄存器相对寻址
(f) 寄存器相对寻址
(g) 相对基址变址寻址

## **Intel 8088和8086采用独立寻址的方式**


