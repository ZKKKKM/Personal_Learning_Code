## 组成
微型计算机又如下组件组成：
	1. 微处理器 (或者中央处理器) （CPU）
	2. 存储器 （Memory）
	3. 输入输出接口和输入输出设备（Input/Output Interfaces and Input/Output Devices）
	4. 总线（Bus）

## 有符号数的原码，反码，补码
##### 原码 (Original Code / Sign-Magnitude)
原码是最直观的表示方法，直接用最高位表示符号，其余位表示数值的绝对值。
- **表示规则：**
    - 正数：符号位为 `0`，数值位为该数的绝对值。
    - 负数：符号位为 `1`，数值位为该数的绝对值。
- **示例（以 8 位二进制为例）：**
    - $+5 \Rightarrow [0000\ 0101]_原$
    - $-5 \Rightarrow [1000\ 0101]_原$
- **缺点：**
    - ==存在“正零”和“负零”两个编码（`00000000` 和 `10000000`）。==
    - 进行减法运算时需要设计额外的硬件电路，逻辑复杂
##### 反码 (Inverse Code / One's Complement)
反码通常作为原码向补码转换的中间状态。
- **表示规则：**
    - ==**正数：反码与原码相同。**==
    - ==**负数：**符号位保持为 `1`，其余各位按位取反（0 变 1，1 变 0）==。
- **示例：**
    - $+5 \Rightarrow [0000\ 0101]_反$
    - $-5 \Rightarrow [1111\ 1010]_反$
- **特点：** 同样存在两个零的问题，目前很少直接用于存储，主要用于转换过程。

##### 补码 (Complement Code / Two's Complement)
**这是计算机系统中实际采用的数值存储方式。** 它完美解决了零的唯一性以及减法运算转化为加法运算的问题。
- **表示规则：**
    - **正数：==补码与原码相同。**==
    - **负数：==在其反码的基础上末位加 1。**（即：原码 $\rightarrow$ 符号位不变，数值位取反 $\rightarrow$ 加 1）。==
- **示例：**
    - $+5 \Rightarrow [0000\ 0101]_补$
    - $-5 \Rightarrow [1111\ 1011]_补$
- **核心优势：**
    1. **零的唯一性：** `0` 在补码中只有一种表示 `00000000`。
    2. **统一加减法：** 减去一个数等于加上这个数的补码。例如 $A - B = A + (-B)_补$。
    3. **多表示一个负数：** 8 位补码可以表示 $-128$，而原码只能表示到 $-127$。

